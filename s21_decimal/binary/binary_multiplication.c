#include "./../helpers/helpers.h"
#include "./binary.h"

/**
 * @brief Функция бинарного умножения двоичных положительных чисел размера 128бит.
 *
 * Функция берет двоичное представление всех 128 бит числа decimal1 и умножает на двоичное представление
 * всех 128 бит числа decimal2
 *
 * Умножение двоичных чисел реализуется по алгоритму с левым сдвигом промежуточных результатов.
 *
 * Результатом будет число размера 256бит, т.к. при умножении нужен регистр результата удвоенной разрядности
 *
 * !Валидация входных данных не осуществляется, как и во всех бинарных функциях. Проверка деления на ноль
 * !должна осуществляться перед вызовом функции.
 *
 * A:      1234567
 * B: *        123
 *       ---------
 * C: =  151851741
 *
 * A:    00000000 00010010 11010110 10000111
 * B: *  00000000 00000000 00000000 01111011
 *       -----------------------------------
 * C: =  00001001 00001101 00010010 11011101
 *
 * Алгоритм:
 * 1) Обнуляем регистр результата C удвоенной разрядности (64 бит). Произведение содержит в два раза больше
 * разрядов чем исходные множители.
 * 2) Анализируем очередной разряд множителя В (начинаем с младших), если он "1", то прибавляем множитель A
 * к регистру С. Если очередной разряд множителя B "0", пропускаем данный шаг.
 * 3) Сдвигаем множитель A на один разряд влево.
 * 4) Действия, описанные в пп. 2 и 3, повторяем пока не будут проанализированы все разряды множителя B.
 *
 * Пример:
 *    C: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
 *   +A: 00000000 00000000 00000000 00000000 00000000 00010010 11010110 10000111
 *       -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00000000 00010010 11010110 10000111
 *
 * A<<1: 00000000 00000000 00000000 00000000 00000000 00100101 10101101 00001110
 *
 *    C: 00000000 00000000 00000000 00000000 00000000 00010010 11010110 10000111
 *   +A: 00000000 00000000 00000000 00000000 00000000 00100101 10101101 00001110
 *       -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00000000 00111000 10000011 10010101
 *
 * A<<1: 00000000 00000000 00000000 00000000 00000000 01001011 01011010 00011100
 *    C: 00000000 00000000 00000000 00000000 00000000 00111000 10000011 10010101
 *   +0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
 *       -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00000000 00111000 10000011 10010101
 *
 * A<<1: 00000000 00000000 00000000 00000000 00000000 10010110 10110100 00111000
 *
 *    C: 00000000 00000000 00000000 00000000 00000000 00111000 10000011 10010101
 *   +A: 00000000 00000000 00000000 00000000 00000000 10010110 10110100 00111000
 *      -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00000000 11001111 00110111 11001101
 *
 * A<<1: 00000000 00000000 00000000 00000000 00000001 00101101 01101000 01110000
 *
 *    C: 00000000 00000000 00000000 00000000 00000000 11001111 00110111 11001101
 *   +A: 00000000 00000000 00000000 00000000 00000001 00101101 01101000 01110000
 *       -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00000001 11111100 10100000 00111101
 *
 * A<<1: 00000000 00000000 00000000 00000000 00000010 01011010 11010000 11100000
 *
 *    C: 00000000 00000000 00000000 00000000 00000001 11111100 10100000 00111101
 *   +A: 00000000 00000000 00000000 00000000 00000010 01011010 11010000 11100000
 *       -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00000100 01010111 01110001 00011101
 *
 * A<<1: 00000000 00000000 00000000 00000000 00000100 10110101 10100001 11000000
 *
 *    C: 00000000 00000000 00000000 00000000 00000100 01010111 01110001 00011101
 *   +A: 00000000 00000000 00000000 00000000 00000100 10110101 10100001 11000000
 *       -----------------------------------------------------------------------
 *    =: 00000000 00000000 00000000 00000000 00001001 00001101 00010010 11011101
 *
 * @author Hubert Furr (hubertfu@student.21-school.ru)
 * @param decimal1 первый множитель
 * @param decimal2 второй множитель
 * @return s21_decimal результат умножения
 */
s21_int256 s21_int128_binary_multiplication(s21_decimal decimal1, s21_decimal decimal2) {
    s21_int256 int256_result = s21_create_int256_from_decimal(s21_decimal_get_zero());
    s21_int256 int256_tmp1 = s21_create_int256_from_decimal(decimal1);

    int max_bit = s21_decimal_get_not_zero_bit(decimal2);

    for (int i = 0; i <= max_bit; i++) {
        if (s21_decimal_is_set_bit(decimal2, i) != 0) {
            int256_result = s21_int256_binary_addition(int256_result, int256_tmp1);
        }
        int256_tmp1 = s21_int256_binary_shift_left(int256_tmp1, 1);
    }

    return int256_result;
}

/**
 * @brief Вспомогательная функция для бинарного умножения двоичных положительных чисел 256бит на 128бит.
 * Алгоритм идентичен s21_int128_binary_multiplication()
 *
 * @author Hubert Furr (hubertfu@student.21-school.ru)
 * @param decimal1 первый множитель
 * @param decimal2 второй множитель
 * @return s21_decimal результат умножения
 */
s21_int256 s21_int256_binary_multiplication(s21_int256 decimal1, s21_decimal decimal2) {
    s21_int256 int256_result = s21_create_int256_from_decimal(s21_decimal_get_zero());
    s21_int256 int256_tmp1 = decimal1;

    int max_bit = s21_decimal_get_not_zero_bit(decimal2);

    for (int i = 0; i <= max_bit; i++) {
        if (s21_decimal_is_set_bit(decimal2, i) != 0) {
            int256_result = s21_int256_binary_addition(int256_result, int256_tmp1);
        }

        int256_tmp1 = s21_int256_binary_shift_left(int256_tmp1, 1);
    }

    return int256_result;
}
